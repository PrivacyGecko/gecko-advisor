import type { PrismaClient } from '@prisma/client';
import { ethers } from 'ethers';
import crypto from 'node:crypto';
import { nanoid } from 'nanoid';
import { logger } from '../logger.js';
import { AuthService, type SafeUser } from './authService.js';

const CHALLENGE_EXPIRATION_MS = 5 * 60 * 1000; // 5 minutes
const MIN_TOKEN_BALANCE = 1000; // Minimum token balance for Pro access

/**
 * In-memory challenge store for verification
 * In production, consider using Redis for distributed systems
 */
interface Challenge {
  message: string;
  timestamp: number;
}

const challengeStore = new Map<string, Challenge>();

/**
 * Wallet authentication result with token and user info
 */
export interface WalletAuthResult {
  token: string;
  user: SafeUser;
  wallet: {
    address: string;
    balance: number;
    isPro: boolean;
  };
  isPro: boolean;
}

/**
 * WalletService handles Web3 wallet authentication including:
 * - Challenge generation for signature verification
 * - Wallet signature verification using ethers.js
 * - Token balance checking for Pro tier access
 * - Wallet linking to existing email accounts
 */
export class WalletService {
  private authService: AuthService;

  constructor(private prisma: PrismaClient) {
    this.authService = new AuthService(prisma);
  }

  /**
   * Generate a unique challenge message for wallet signature
   * Challenge format: "Sign this message to authenticate with Privacy Advisor: [nonce] [timestamp]"
   *
   * @param walletAddress Ethereum wallet address
   * @returns Challenge message string
   */
  generateChallenge(walletAddress: string): string {
    const normalizedAddress = walletAddress.toLowerCase();
    const nonce = nanoid(16);
    const timestamp = Date.now();

    const message = `Sign this message to authenticate with Privacy Advisor:\n\nWallet: ${normalizedAddress}\nNonce: ${nonce}\nTimestamp: ${timestamp}`;

    // Store challenge for verification
    challengeStore.set(normalizedAddress, {
      message,
      timestamp,
    });

    // Clean up expired challenges
    this.cleanupExpiredChallenges();

    logger.debug({ walletAddress: normalizedAddress }, 'Challenge generated for wallet');
    return message;
  }

  /**
   * Verify wallet signature against stored challenge
   * Uses ethers.js to recover signer address from signature
   *
   * @param walletAddress Claimed wallet address
   * @param signature Signature string from wallet
   * @param message Original challenge message
   * @returns true if signature is valid, false otherwise
   */
  async verifySignature(
    walletAddress: string,
    signature: string,
    message: string
  ): Promise<boolean> {
    try {
      const normalizedAddress = walletAddress.toLowerCase();

      // Verify challenge exists and hasn't expired
      const storedChallenge = challengeStore.get(normalizedAddress);
      if (!storedChallenge) {
        logger.warn({ walletAddress: normalizedAddress }, 'No challenge found for wallet');
        return false;
      }

      if (Date.now() - storedChallenge.timestamp > CHALLENGE_EXPIRATION_MS) {
        logger.warn({ walletAddress: normalizedAddress }, 'Challenge expired for wallet');
        challengeStore.delete(normalizedAddress);
        return false;
      }

      if (storedChallenge.message !== message) {
        logger.warn({ walletAddress: normalizedAddress }, 'Challenge message mismatch');
        return false;
      }

      // Verify signature using ethers.js
      const recoveredAddress = ethers.verifyMessage(message, signature);

      // Compare addresses (case-insensitive)
      const isValid =
        recoveredAddress.toLowerCase() === normalizedAddress;

      if (isValid) {
        logger.info({ walletAddress: normalizedAddress }, 'Wallet signature verified successfully');
        // Clean up used challenge
        challengeStore.delete(normalizedAddress);
      } else {
        logger.warn(
          {
            walletAddress: normalizedAddress,
            recoveredAddress,
          },
          'Wallet signature verification failed: address mismatch'
        );
      }

      return isValid;
    } catch (error) {
      logger.error(
        { error, walletAddress },
        'Wallet signature verification failed with error'
      );
      return false;
    }
  }

  /**
   * Check wallet token balance to determine Pro eligibility
   * In MVP, this is a placeholder that returns mock data
   * In production, integrate with actual blockchain RPC or API
   *
   * @param walletAddress Ethereum wallet address
   * @returns Token balance amount
   */
  async checkTokenBalance(walletAddress: string): Promise<number> {
    // TODO: Implement actual token balance checking
    // Options:
    // 1. Use ethers.js with RPC provider to query ERC-20 contract
    // 2. Use blockchain API service (Alchemy, Infura, etc.)
    // 3. Use indexer service for cached balance data

    logger.debug(
      { walletAddress },
      'Checking token balance (placeholder implementation)'
    );

    // Placeholder: Return mock balance for testing
    // In production, this would be:
    // const provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
    // const contract = new ethers.Contract(tokenAddress, abi, provider);
    // const balance = await contract.balanceOf(walletAddress);
    // return Number(ethers.formatUnits(balance, decimals));

    return 0; // Default to 0 tokens (FREE tier)
  }

  /**
   * Authenticate user with wallet signature
   * Creates new user if wallet is not linked to any account
   * Returns JWT token and user info with wallet details
   *
   * @param walletAddress Ethereum wallet address
   * @param signature Wallet signature
   * @param message Original challenge message
   * @returns Authentication result with token and user
   * @throws Error if signature is invalid
   */
  async authenticateWallet(
    walletAddress: string,
    signature: string,
    message: string
  ): Promise<WalletAuthResult> {
    logger.info({ walletAddress }, 'Authenticating wallet');

    // Verify signature
    const isValid = await this.verifySignature(walletAddress, signature, message);
    if (!isValid) {
      throw new Error('INVALID_SIGNATURE');
    }

    const normalizedAddress = walletAddress.toLowerCase();
    const addressHash = this.hashWalletAddress(normalizedAddress);

    // Check if wallet is already linked to a user
    const walletLink = await this.prisma.walletLink.findUnique({
      where: { walletAddressHash: addressHash },
      include: { user: true },
    });

    let user: SafeUser;

    if (walletLink) {
      // Update last verified timestamp
      await this.prisma.walletLink.update({
        where: { id: walletLink.id },
        data: { lastVerified: new Date() },
      });

      user = this.authService['sanitizeUser'](walletLink.user);
      logger.info({ userId: user.id, walletAddress }, 'Existing wallet link authenticated');
    } else {
      // Create new user with wallet authentication
      const newUser = await this.prisma.user.create({
        data: {
          email: `${normalizedAddress}@wallet.geckoadvisor.com`, // Synthetic email
          authMethod: 'WALLET',
          subscription: 'FREE',
          subscriptionStatus: 'INACTIVE',
        },
      });

      // Create wallet link
      await this.prisma.walletLink.create({
        data: {
          userId: newUser.id,
          walletAddressHash: addressHash,
        },
      });

      user = this.authService['sanitizeUser'](newUser);
      logger.info({ userId: user.id, walletAddress }, 'New wallet user created');
    }

    // Check token balance for Pro eligibility
    const tokenBalance = await this.checkTokenBalance(normalizedAddress);
    const isPro = tokenBalance >= MIN_TOKEN_BALANCE;

    // Update user subscription if they have enough tokens
    if (isPro && user.subscription !== 'PRO') {
      await this.prisma.user.update({
        where: { id: user.id },
        data: {
          subscription: 'PRO',
          subscriptionStatus: 'ACTIVE',
        },
      });

      user.subscription = 'PRO';
      user.subscriptionStatus = 'ACTIVE';

      logger.info(
        { userId: user.id, tokenBalance },
        'User upgraded to Pro based on token balance'
      );
    }

    // Generate JWT token
    const token = this.authService.generateToken(user.id);

    return {
      token,
      user,
      wallet: {
        address: normalizedAddress,
        balance: tokenBalance,
        isPro,
      },
      isPro,
    };
  }

  /**
   * Link wallet to existing authenticated user
   * Requires user to be authenticated via JWT and wallet signature to be valid
   *
   * @param userId User ID from JWT token
   * @param walletAddress Ethereum wallet address
   * @param signature Wallet signature
   * @param message Original challenge message
   * @returns Wallet details with balance and Pro status
   * @throws Error if signature is invalid or wallet is already linked
   */
  async linkWallet(
    userId: string,
    walletAddress: string,
    signature: string,
    message: string
  ): Promise<{ address: string; balance: number; isPro: boolean }> {
    logger.info({ userId, walletAddress }, 'Linking wallet to user');

    // Verify signature
    const isValid = await this.verifySignature(walletAddress, signature, message);
    if (!isValid) {
      throw new Error('INVALID_SIGNATURE');
    }

    const normalizedAddress = walletAddress.toLowerCase();
    const addressHash = this.hashWalletAddress(normalizedAddress);

    // Check if wallet is already linked to any user
    const existingLink = await this.prisma.walletLink.findUnique({
      where: { walletAddressHash: addressHash },
    });

    if (existingLink) {
      if (existingLink.userId === userId) {
        logger.info({ userId, walletAddress }, 'Wallet already linked to this user');
        // Update last verified timestamp
        await this.prisma.walletLink.update({
          where: { id: existingLink.id },
          data: { lastVerified: new Date() },
        });
      } else {
        logger.warn({ userId, walletAddress }, 'Wallet already linked to another user');
        throw new Error('WALLET_ALREADY_LINKED');
      }
    } else {
      // Create new wallet link
      await this.prisma.walletLink.create({
        data: {
          userId,
          walletAddressHash: addressHash,
        },
      });

      logger.info({ userId, walletAddress }, 'Wallet linked successfully');
    }

    // Check token balance and update user subscription
    const tokenBalance = await this.checkTokenBalance(normalizedAddress);
    const isPro = tokenBalance >= MIN_TOKEN_BALANCE;

    if (isPro) {
      await this.prisma.user.update({
        where: { id: userId },
        data: {
          subscription: 'PRO',
          subscriptionStatus: 'ACTIVE',
          authMethod: 'BOTH', // User now has both email and wallet auth
        },
      });

      logger.info(
        { userId, tokenBalance },
        'User upgraded to Pro after wallet link'
      );
    } else {
      // Just update auth method
      await this.prisma.user.update({
        where: { id: userId },
        data: {
          authMethod: 'BOTH',
        },
      });
    }

    return {
      address: normalizedAddress,
      balance: tokenBalance,
      isPro,
    };
  }

  /**
   * Disconnect wallet from user account
   * Removes wallet link but keeps user account intact
   *
   * @param userId User ID from JWT token
   * @throws Error if no wallet is linked
   */
  async disconnectWallet(userId: string): Promise<void> {
    logger.info({ userId }, 'Disconnecting wallet from user');

    const walletLink = await this.prisma.walletLink.findUnique({
      where: { userId },
    });

    if (!walletLink) {
      logger.warn({ userId }, 'No wallet linked to disconnect');
      throw new Error('NO_WALLET_LINKED');
    }

    // Remove wallet link
    await this.prisma.walletLink.delete({
      where: { userId },
    });

    // Update user auth method
    const user = await this.prisma.user.findUnique({
      where: { id: userId },
    });

    if (user) {
      // If user had wallet-only auth, they can't authenticate anymore
      // This should be prevented in the frontend
      const newAuthMethod =
        user.authMethod === 'BOTH' ? 'EMAIL' : user.authMethod;

      await this.prisma.user.update({
        where: { id: userId },
        data: {
          authMethod: newAuthMethod,
          // Downgrade to FREE if they were Pro via tokens
          subscription:
            user.subscription === 'PRO' && !user.stripeSubscriptionId
              ? 'FREE'
              : user.subscription,
          subscriptionStatus:
            user.subscription === 'PRO' && !user.stripeSubscriptionId
              ? 'INACTIVE'
              : user.subscriptionStatus,
        },
      });
    }

    logger.info({ userId }, 'Wallet disconnected successfully');
  }

  /**
   * Get wallet status for authenticated user
   *
   * @param userId User ID from JWT token
   * @returns Wallet connection status and details
   */
  async getWalletStatus(
    userId: string
  ): Promise<{ connected: boolean; address?: string; balance?: number; isPro?: boolean }> {
    const walletLink = await this.prisma.walletLink.findUnique({
      where: { userId },
    });

    if (!walletLink) {
      return { connected: false };
    }

    // Note: We can't retrieve the original address from hash
    // Frontend should track the address after successful authentication
    // For now, return placeholder
    return {
      connected: true,
      address: 'Connected',
      balance: 0,
      isPro: false,
    };
  }

  /**
   * Hash wallet address for privacy-preserving storage
   * Uses SHA-256 to create one-way hash
   *
   * @param walletAddress Ethereum wallet address
   * @returns Hashed address string
   */
  private hashWalletAddress(walletAddress: string): string {
    return crypto
      .createHash('sha256')
      .update(walletAddress.toLowerCase())
      .digest('hex');
  }

  /**
   * Clean up expired challenges from in-memory store
   * Removes challenges older than expiration time
   */
  private cleanupExpiredChallenges(): void {
    const now = Date.now();
    for (const [address, challenge] of challengeStore.entries()) {
      if (now - challenge.timestamp > CHALLENGE_EXPIRATION_MS) {
        challengeStore.delete(address);
      }
    }
  }
}
